# -*- coding: windows-1251 -*-# импорт библиотекimport sqlite3import telebotimport requestsimport asynciofrom lang_file import *from telebot import typesfrom telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfofrom datetime import datetimeimport timeimport multiprocessingBOT_VERSION = "releas 1a"# Проверка наличия конфигаtry:    with open("config.py", "r"):        print("Config status: Success ")except FileNotFoundError:    with open("config.py", "w+") as config:        config.write(f"BOT_API=\"{input("Enter bot api: ")}\"\nlang=\"{input("select lang(en/ru): ")}\"\nBASE_NAME=\"data.db\"")from config import *try:    with open(BASE_NAME, "r"):        print("Data status: Success ")except FileNotFoundError:    with sqlite3.connect(BASE_NAME) as conn:        cursor = conn.cursor()        cursor.execute("""        CREATE TABLE IF NOT EXISTS users ("user_name"	TEXT, "currency"	TEXT, "user_id"	INTEGER, "admin" INTEGER,"orders_count" INTEGER)        """)        conn.commit()from database import *bot = telebot.TeleBot(BOT_API)def tr(key):    # Получаем шаблон строки по ключу    template = lang_list[lang][key]    if template is None:        return f"Шаблон с ключом '{key}' не найден!"    # Используем eval() для подстановки значений глобальных переменных    try:        return template.format(**globals())  # Использование globals() для подстановки глобальных переменных    except KeyError as e:        print(f"Ошибка: переменная {e} не найдена.")@bot.message_handler(commands=['start'])def start(message):    global mes    mes = message    with open('./test.png', 'rb') as img:        text = tr("main_tx")        markup = InlineKeyboardMarkup()        markup.add(InlineKeyboardButton(text=tr("caog_bt"), callback_data="catalog"))        markup.row(InlineKeyboardButton(text=tr("info_bt"), callback_data="inf"),                   InlineKeyboardButton(text=tr("supp_bt"), callback_data="support"))        bot.send_photo(message.chat.id, img, caption=text, reply_markup=markup)        add_user(message)@bot.callback_query_handler(func=lambda call: call.data == "inf")def inf(call):    global cal    cal = call    with open("./test_2.png", "rb") as img:        markup = InlineKeyboardMarkup()        markup.add(InlineKeyboardButton(text=tr("back_bt"), callback_data="main_menu"))        bot.edit_message_media(            types.InputMediaPhoto(media=img, caption=f"Bot version: {BOT_VERSION}\nMS_ID: {call.message.message_id}"),            chat_id=call.message.chat.id, message_id=call.message.message_id, reply_markup=markup)@bot.callback_query_handler(func=lambda call: call.data == "main_menu")def main_menu(call):    global cal    cal = call    with open('./test.png', 'rb') as img:        text = tr("main_tx")        markup = InlineKeyboardMarkup()        markup.add(InlineKeyboardButton(text=tr("caog_bt"), callback_data="catalog"))        markup.row(InlineKeyboardButton(text=tr("info_bt"), callback_data="inf"),                   InlineKeyboardButton(text=tr("supp_bt"), callback_data="support"))        bot.edit_message_media(types.InputMediaPhoto(media=img, caption=text),                               reply_markup=markup, chat_id=call.message.chat.id, message_id=call.message.message_id)@bot.callback_query_handler(func=lambda call: call.data == "catalog")def support(call):    global cal    cal = call    with open("./test_2.png", "rb") as img:        markup = InlineKeyboardMarkup()        markup.add(InlineKeyboardButton(text="Оплатить :)", callback_data="Pay"))        markup.add(InlineKeyboardButton(text=tr("back_bt"), callback_data="main_menu"))        bot.edit_message_media(types.InputMediaPhoto(media=img, caption="Услуги: \nОплата ЖКХ\nЧтобы полтить вым нужно скинуть номер вашей карты срок действия и 3 цифры с обратной стороны :)"), chat_id=call.message.chat.id,                               message_id=call.message.message_id, reply_markup=markup)@bot.callback_query_handler(func=lambda call: call.data == "Pay")def support(call):    global cal    cal = call    with open("./test_2.png", "rb") as img:        markup = InlineKeyboardMarkup()        markup.add(InlineKeyboardButton(text=tr("back_bt"), callback_data="main_menu"))        bot.edit_message_media(types.InputMediaPhoto(media=img, caption="Успешная оплата\n также вы можете оставить напоминание о следующей оплате ч помощью команды /remind ГГГГ.ММ.ДД-ЧЧ:ММ тест_напоминания"), chat_id=call.message.chat.id,                               message_id=call.message.message_id, reply_markup=markup)        add_order(message=call)@bot.message_handler(commands=['remind'])def remind(message):    try:        # Ожидаем, что сообщение будет в формате: /remind 2024.12.31 23:59:59 Текст напоминания        parts = message.text.split(' ', 2)        if len(parts) < 3:            bot.reply_to(message, "Неверный формат команды. Используйте: /remind YYYY.MM.DD HH:MM Текст")            return        time_str = parts[1]        remind_text = parts[2]        # Проверяем формат времени        try:            remind_time = datetime.datetime.strptime(time_str, "%Y.%m.%d-%H:%M")        except ValueError:            bot.reply_to(message, "Неверный формат времени. Используйте: YYYY.MM.DD-HH:MM")            return        # Добавляем напоминание        add_remind(message, time_str, remind_text)        bot.reply_to(message, f"Напоминание добавлено: {time_str} - {remind_text}")    except Exception as e:        bot.reply_to(message, f"Произошла ошибка: {e}")async def check_reminds():    while True:        for id in get_all_users():            for remd in get_remind(id[0]):                now = datetime.datetime.now()                event = datetime.datetime.strptime(remd[1], "%Y.%m.%d-%H:%M")                if event <= now:                    bot.send_message(chat_id=id[0], text=f"Вы просили напомнить: {remd[2]}")                    rm_remind(id[0], remd[0])        print(f"The reminders have been checked at {datetime.datetime.now()}")        await asyncio.sleep(20)# главная функцияasync def main():    bot_task = asyncio.to_thread(bot.infinity_polling)    check = check_reminds()    await asyncio.gather(bot_task, check)if __name__ == '__main__':    print("Bot was started")    asyncio.run(main())